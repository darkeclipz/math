{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Math Notes This MkDocs site contains my math notes, which I started to save here in 2022. The goal of this website is to create a small explanation or reference to the mathematics I encounter, in the hope that I remember it better. The goal is not to explain it here, it simply acts as a reference. There are tons of material out there from which you can learn this. Contents Currently only the Calculus section is being filled, since my goal is to finish the multi variable calculus section, and vector calculus, since my bachelor Applied Mathematics has skipped these wonderful chapters.","title":"Math Notes"},{"location":"#math-notes","text":"This MkDocs site contains my math notes, which I started to save here in 2022. The goal of this website is to create a small explanation or reference to the mathematics I encounter, in the hope that I remember it better. The goal is not to explain it here, it simply acts as a reference. There are tons of material out there from which you can learn this.","title":"Math Notes"},{"location":"#contents","text":"Currently only the Calculus section is being filled, since my goal is to finish the multi variable calculus section, and vector calculus, since my bachelor Applied Mathematics has skipped these wonderful chapters.","title":"Contents"},{"location":"references/","text":"References Cheat sheets about many topics: https://stanford.edu/~shervine/teaching The color spectrum and going to sRGB: https://ciechanow.ski/color-spaces/","title":"References"},{"location":"references/#references","text":"Cheat sheets about many topics: https://stanford.edu/~shervine/teaching The color spectrum and going to sRGB: https://ciechanow.ski/color-spaces/","title":"References"},{"location":"algebra/algebra/","text":"Algebra","title":"Algebra"},{"location":"algebra/algebra/#algebra","text":"","title":"Algebra"},{"location":"calculus/multi-variable/derivatives/","text":"Multivariable derivatives Formal definition Let \\(f(x, y)\\) be a function with two variables, then the formal definition of the partial derivative of \\(f\\) with respect to \\(x\\) is: \\[ \\dfrac{\\partial f}{\\partial x} = \\lim_{h \\rightarrow 0} \\dfrac{f(x + h, y) - f(x, y)}{h} \\] Likewise for \\(f\\) with respect to \\(y\\) , the partial derivative is: \\[ \\dfrac{\\partial f}{\\partial y} = \\lim_{h \\rightarrow 0} \\dfrac{f(x, y + h) - f(x, y)}{h} \\] The main take away is that we give a small nudge to the variable we want to get the derivative of. Symmetry in higher order derivatives A higher order derivative is when we take the derivative of a function multiple times. This is denoted as \\[ \\dfrac{\\partial^2f}{\\partial x^2} \\] which means that we first take the derivative with respect to \\(x\\) , and then a second time with respect to \\(x\\) . Likewise, we can also take the derivative with respect to \\(x\\) , and then with respect to \\(y\\) . A beautiful result of this, is that this is the same as taking the derivative first with respect to \\(y\\) , and then with respect to \\(x\\) , which means that: \\[ \\dfrac{\\partial^2f}{\\partial x \\partial y} = \\dfrac{\\partial^2f}{\\partial y \\partial x}. \\] Note The notion of a higher order derivative is only applicable if the order of the derivative is continuous around a point \\(P\\) , e.g. the point we are evaluating. Simpler notation If you get tired of writing \\(\\dfrac{\\partial^2f}{\\partial x \\partial y}\\) , this can be written simpler as \\(f_{xy}\\) . Gradient Let \\(f(x_1, x_2, \\ldots, x_n)\\) be a multivariable function with \\(n\\) variables, then the gradient of \\(f\\) is: \\[ \\nabla f = \\begin{bmatrix} \\dfrac{\\partial}{\\partial x_1} \\\\ \\dfrac{\\partial}{\\partial x_2} \\\\ \\vdots \\\\ \\dfrac{\\partial}{\\partial x_n} \\end{bmatrix} f = \\begin{bmatrix} \\dfrac{\\partial f}{\\partial x_1} \\\\ \\dfrac{\\partial f}{\\partial x_2} \\\\ \\vdots \\\\ \\dfrac{\\partial f}{\\partial x_n} \\end{bmatrix}. \\] The \\(\\nabla\\) (nabla) symbol denotes a vector of differential operators, so \\(\\nabla f\\) , means that we apply the operator \\(\\nabla\\) to \\(f\\) . Visual example of the gradient Let \\(f(x, y) = x^2 + y^2\\) . The illustration below is the graph of \\(f\\) . We can find the gradient of \\(f\\) , which is \\(\\nabla f = \\begin{bmatrix} 2x & 2y \\end{bmatrix}^T\\) . To visualize the gradient, we create a vector field plot of \\(\\nabla f\\) , which is also called the gradient plot: Here we can see that each of the vectors point in the direction of the steepest ascent. Or in other words, the gradient points into the direction of the steepest ascent . Another thing to note, is that the gradient vector is always perpendicular to contour lines. Note It is not guaranteed that it points towards the highest point in the function, it only points in the direction of the steepest ascent! Directional derivative As of now we have only looked at partial derivatives such as \\(\\dfrac{\\partial f}{\\partial x}\\) which is the derivative in the \\(x\\) direction, and likewise \\(\\dfrac{\\partial f}{\\partial y}\\) is the derivative in the \\(y\\) -direction. However, we can also take the derivative in any other direction, which is known as the directional derivative. Let \\(f(x, y)\\) be a function and suppose we want to take the derivative in the direction of \\(\\vec{v} = (-1, 2)\\) . The directional derivative then is: \\[ \\nabla_{\\vec v} f(x, y) = -\\dfrac{\\partial f}{\\partial x} + 2\\dfrac{\\partial f}{\\partial y}. \\] Note that \\(\\nabla_{\\vec v}\\) is used to denote the gradient of \\(f\\) in the direction of \\(\\vec{v}\\) . As you can see, we simply take the linear combination of the partial derivatives and each of the corresponding components in \\(\\vec{v}\\) . The sharp eyed reader will see that this is the dot-product of \\(\\vec{v}\\) and the gradient of \\(f\\) , thus: \\[ \\nabla_{\\vec{v}}f(x, y) = \\vec{v} \\cdot \\nabla f = \\begin{bmatrix}\\vec{v}_x \\\\ \\vec{v}_y \\end{bmatrix} \\cdot \\begin{bmatrix} \\dfrac{\\partial f}{\\partial x} \\\\ \\dfrac{\\partial f}{\\partial y} \\end{bmatrix}. \\] Note that \\(\\vec{v}\\cdot\\nabla f\\) is still a function, and we need to evaluate it at a point \\(\\vec{a}\\) to get the scalar value. This also leads to the formal defintion of the directional derivative, which is defined as: \\[ \\nabla_{\\vec{v}} f(\\vec{a}) = \\lim_{h \\rightarrow 0} \\dfrac{f(\\vec{a} + h\\vec{v}) - f(\\vec{a})}{h}. \\] The directional derivative can be defined in any direction, but a particular interesting one is in the direction of the steepest ascent, which is given by the gradient. This is useful to find a local optimum or minimum. More about this later when we are discussing the applications of multivariable derivatives. Note Note that \\(\\vec{v} \\cdot \\nabla f\\) is a dot-product of two vectors, which results in a scalar value (if \\(f\\) is evaluated). Caution If the scalar value is to be interpreted as a slope, then \\(\\vec{v}\\) must be a unit vector, e.g. \\(||\\ \\vec{v}\\ || = 1\\) . Vector-valued functions Suppose we have a curve \\(C\\) which is parametrized by \\(x = x(t)\\) and \\(y = y(t)\\) on the interval \\(a \\leq t \\leq b\\) , then we can vectorize this in the following way: \\[ \\vec{r}(t) = \\begin{bmatrix} x(t) \\\\ y(t) \\end{bmatrix} \\] Note that \\(\\vec{r}(t)\\) is a vector-valued function. Another way of writing this is using the unit vectors \\(\\hat{i}\\) and \\(\\hat{j}\\) , giving \\(\\vec{r}(t) = x(t)\\hat{i} + y(t)\\hat{j}\\) . The formal definition of the derivative of a vector-valued function is: \\[ \\lim_{h \\rightarrow 0} \\dfrac{\\vec{r}(t + h) - \\vec{r}(t)}{h}. \\] This can then be used to find the derivative of a vector-valued function. This is useful to find for example the velocity of \\(\\vec{r}(t)\\) which is \\(x'(t)\\hat{i} + y'(t)\\hat{j}\\) , or the speed which is \\(\\sqrt{(x'(t))^2 + (y'(t))^2}\\) . Multivariable chain rule Suppose we have a function \\(f(x, y)\\) with \\(x(t)\\) and \\(y(t)\\) , then we want to find the derivative of \\(f(x(t), y(t))\\) . Simply plugging all the values in and taking the ordinary derivative will give us the result. However, if you take notice, you will see that it will be in the form of: \\[ \\dfrac{\\mathrm{d}}{\\mathrm{d}t} \\Big( f(x(t), y(t)) \\Big) = \\dfrac{\\partial f}{\\partial x}\\cdot \\dfrac{\\mathrm{d}x}{\\mathrm{d}t} + \\dfrac{\\partial f}{\\partial y}\\cdot \\dfrac{\\mathrm{d}y}{\\mathrm{d}t}. \\] This derivative gives the change in \\(f\\) by the change of \\(t\\) . Note that this is the dot-product of the partial derivatives and the ordinary derivatives. Let \\(\\vec{v} = (x(t), y(y))\\) . We know that the vector of partial derivatives of \\(f\\) is the gradient of \\(f\\) . The other vector is a vector with the ordinary derivatives. Rewriting this in vector notation gives \\[ \\nabla f(\\vec{v}(t)) \\cdot \\vec{v}'(t) = \\begin{bmatrix} \\dfrac{\\partial f}{\\partial x} \\\\ \\dfrac{\\partial f}{\\partial y} \\end{bmatrix} \\cdot \\begin{bmatrix} \\dfrac{\\mathrm{d}x}{\\mathrm{d}t} \\\\ \\dfrac{\\mathrm{d}y}{\\mathrm{d}t} \\end{bmatrix}, \\] which is the generalized multivariable chain rule. This example only shows two variables, but this extends to any number of variables. Also note that \\(f\\) is a scalar-valued function that is composed with a vector-valued function. In other words, the input is one dimension, the function in between can be in any dimensions, and the output is again in one dimension. The dimension of \\(f\\) is obviously determined by the number of components that are in the output of the vector-valued function. Notice the similarity with the definition of the directional derivative. By giving a small nudge to \\(t\\) , we are moving the \\(\\vec{v}\\) a little bit, and as a result we have a small change in \\(f\\) . The change in \\(f\\) is given by the derivative of \\(\\vec{v}\\) . Or in other words, we are moving into the direction of \\(\\vec{v}'(t)\\) . This beautiful results tells us that the multivariable chain rule is essentially a directional derivative in the direction of \\(\\vec v'(t)\\) : \\[ \\nabla f(\\vec{v}(t)) \\cdot \\vec{v}'(t) = \\nabla_{\\vec{v}'(t)} f(\\vec v(t)). \\]","title":"Multivariable derivatives"},{"location":"calculus/multi-variable/derivatives/#multivariable-derivatives","text":"","title":"Multivariable derivatives"},{"location":"calculus/multi-variable/derivatives/#formal-definition","text":"Let \\(f(x, y)\\) be a function with two variables, then the formal definition of the partial derivative of \\(f\\) with respect to \\(x\\) is: \\[ \\dfrac{\\partial f}{\\partial x} = \\lim_{h \\rightarrow 0} \\dfrac{f(x + h, y) - f(x, y)}{h} \\] Likewise for \\(f\\) with respect to \\(y\\) , the partial derivative is: \\[ \\dfrac{\\partial f}{\\partial y} = \\lim_{h \\rightarrow 0} \\dfrac{f(x, y + h) - f(x, y)}{h} \\] The main take away is that we give a small nudge to the variable we want to get the derivative of.","title":"Formal definition"},{"location":"calculus/multi-variable/derivatives/#symmetry-in-higher-order-derivatives","text":"A higher order derivative is when we take the derivative of a function multiple times. This is denoted as \\[ \\dfrac{\\partial^2f}{\\partial x^2} \\] which means that we first take the derivative with respect to \\(x\\) , and then a second time with respect to \\(x\\) . Likewise, we can also take the derivative with respect to \\(x\\) , and then with respect to \\(y\\) . A beautiful result of this, is that this is the same as taking the derivative first with respect to \\(y\\) , and then with respect to \\(x\\) , which means that: \\[ \\dfrac{\\partial^2f}{\\partial x \\partial y} = \\dfrac{\\partial^2f}{\\partial y \\partial x}. \\] Note The notion of a higher order derivative is only applicable if the order of the derivative is continuous around a point \\(P\\) , e.g. the point we are evaluating.","title":"Symmetry in higher order derivatives"},{"location":"calculus/multi-variable/derivatives/#simpler-notation","text":"If you get tired of writing \\(\\dfrac{\\partial^2f}{\\partial x \\partial y}\\) , this can be written simpler as \\(f_{xy}\\) .","title":"Simpler notation"},{"location":"calculus/multi-variable/derivatives/#gradient","text":"Let \\(f(x_1, x_2, \\ldots, x_n)\\) be a multivariable function with \\(n\\) variables, then the gradient of \\(f\\) is: \\[ \\nabla f = \\begin{bmatrix} \\dfrac{\\partial}{\\partial x_1} \\\\ \\dfrac{\\partial}{\\partial x_2} \\\\ \\vdots \\\\ \\dfrac{\\partial}{\\partial x_n} \\end{bmatrix} f = \\begin{bmatrix} \\dfrac{\\partial f}{\\partial x_1} \\\\ \\dfrac{\\partial f}{\\partial x_2} \\\\ \\vdots \\\\ \\dfrac{\\partial f}{\\partial x_n} \\end{bmatrix}. \\] The \\(\\nabla\\) (nabla) symbol denotes a vector of differential operators, so \\(\\nabla f\\) , means that we apply the operator \\(\\nabla\\) to \\(f\\) .","title":"Gradient"},{"location":"calculus/multi-variable/derivatives/#visual-example-of-the-gradient","text":"Let \\(f(x, y) = x^2 + y^2\\) . The illustration below is the graph of \\(f\\) . We can find the gradient of \\(f\\) , which is \\(\\nabla f = \\begin{bmatrix} 2x & 2y \\end{bmatrix}^T\\) . To visualize the gradient, we create a vector field plot of \\(\\nabla f\\) , which is also called the gradient plot: Here we can see that each of the vectors point in the direction of the steepest ascent. Or in other words, the gradient points into the direction of the steepest ascent . Another thing to note, is that the gradient vector is always perpendicular to contour lines. Note It is not guaranteed that it points towards the highest point in the function, it only points in the direction of the steepest ascent!","title":"Visual example of the gradient"},{"location":"calculus/multi-variable/derivatives/#directional-derivative","text":"As of now we have only looked at partial derivatives such as \\(\\dfrac{\\partial f}{\\partial x}\\) which is the derivative in the \\(x\\) direction, and likewise \\(\\dfrac{\\partial f}{\\partial y}\\) is the derivative in the \\(y\\) -direction. However, we can also take the derivative in any other direction, which is known as the directional derivative. Let \\(f(x, y)\\) be a function and suppose we want to take the derivative in the direction of \\(\\vec{v} = (-1, 2)\\) . The directional derivative then is: \\[ \\nabla_{\\vec v} f(x, y) = -\\dfrac{\\partial f}{\\partial x} + 2\\dfrac{\\partial f}{\\partial y}. \\] Note that \\(\\nabla_{\\vec v}\\) is used to denote the gradient of \\(f\\) in the direction of \\(\\vec{v}\\) . As you can see, we simply take the linear combination of the partial derivatives and each of the corresponding components in \\(\\vec{v}\\) . The sharp eyed reader will see that this is the dot-product of \\(\\vec{v}\\) and the gradient of \\(f\\) , thus: \\[ \\nabla_{\\vec{v}}f(x, y) = \\vec{v} \\cdot \\nabla f = \\begin{bmatrix}\\vec{v}_x \\\\ \\vec{v}_y \\end{bmatrix} \\cdot \\begin{bmatrix} \\dfrac{\\partial f}{\\partial x} \\\\ \\dfrac{\\partial f}{\\partial y} \\end{bmatrix}. \\] Note that \\(\\vec{v}\\cdot\\nabla f\\) is still a function, and we need to evaluate it at a point \\(\\vec{a}\\) to get the scalar value. This also leads to the formal defintion of the directional derivative, which is defined as: \\[ \\nabla_{\\vec{v}} f(\\vec{a}) = \\lim_{h \\rightarrow 0} \\dfrac{f(\\vec{a} + h\\vec{v}) - f(\\vec{a})}{h}. \\] The directional derivative can be defined in any direction, but a particular interesting one is in the direction of the steepest ascent, which is given by the gradient. This is useful to find a local optimum or minimum. More about this later when we are discussing the applications of multivariable derivatives. Note Note that \\(\\vec{v} \\cdot \\nabla f\\) is a dot-product of two vectors, which results in a scalar value (if \\(f\\) is evaluated). Caution If the scalar value is to be interpreted as a slope, then \\(\\vec{v}\\) must be a unit vector, e.g. \\(||\\ \\vec{v}\\ || = 1\\) .","title":"Directional derivative"},{"location":"calculus/multi-variable/derivatives/#vector-valued-functions","text":"Suppose we have a curve \\(C\\) which is parametrized by \\(x = x(t)\\) and \\(y = y(t)\\) on the interval \\(a \\leq t \\leq b\\) , then we can vectorize this in the following way: \\[ \\vec{r}(t) = \\begin{bmatrix} x(t) \\\\ y(t) \\end{bmatrix} \\] Note that \\(\\vec{r}(t)\\) is a vector-valued function. Another way of writing this is using the unit vectors \\(\\hat{i}\\) and \\(\\hat{j}\\) , giving \\(\\vec{r}(t) = x(t)\\hat{i} + y(t)\\hat{j}\\) . The formal definition of the derivative of a vector-valued function is: \\[ \\lim_{h \\rightarrow 0} \\dfrac{\\vec{r}(t + h) - \\vec{r}(t)}{h}. \\] This can then be used to find the derivative of a vector-valued function. This is useful to find for example the velocity of \\(\\vec{r}(t)\\) which is \\(x'(t)\\hat{i} + y'(t)\\hat{j}\\) , or the speed which is \\(\\sqrt{(x'(t))^2 + (y'(t))^2}\\) .","title":"Vector-valued functions"},{"location":"calculus/multi-variable/derivatives/#multivariable-chain-rule","text":"Suppose we have a function \\(f(x, y)\\) with \\(x(t)\\) and \\(y(t)\\) , then we want to find the derivative of \\(f(x(t), y(t))\\) . Simply plugging all the values in and taking the ordinary derivative will give us the result. However, if you take notice, you will see that it will be in the form of: \\[ \\dfrac{\\mathrm{d}}{\\mathrm{d}t} \\Big( f(x(t), y(t)) \\Big) = \\dfrac{\\partial f}{\\partial x}\\cdot \\dfrac{\\mathrm{d}x}{\\mathrm{d}t} + \\dfrac{\\partial f}{\\partial y}\\cdot \\dfrac{\\mathrm{d}y}{\\mathrm{d}t}. \\] This derivative gives the change in \\(f\\) by the change of \\(t\\) . Note that this is the dot-product of the partial derivatives and the ordinary derivatives. Let \\(\\vec{v} = (x(t), y(y))\\) . We know that the vector of partial derivatives of \\(f\\) is the gradient of \\(f\\) . The other vector is a vector with the ordinary derivatives. Rewriting this in vector notation gives \\[ \\nabla f(\\vec{v}(t)) \\cdot \\vec{v}'(t) = \\begin{bmatrix} \\dfrac{\\partial f}{\\partial x} \\\\ \\dfrac{\\partial f}{\\partial y} \\end{bmatrix} \\cdot \\begin{bmatrix} \\dfrac{\\mathrm{d}x}{\\mathrm{d}t} \\\\ \\dfrac{\\mathrm{d}y}{\\mathrm{d}t} \\end{bmatrix}, \\] which is the generalized multivariable chain rule. This example only shows two variables, but this extends to any number of variables. Also note that \\(f\\) is a scalar-valued function that is composed with a vector-valued function. In other words, the input is one dimension, the function in between can be in any dimensions, and the output is again in one dimension. The dimension of \\(f\\) is obviously determined by the number of components that are in the output of the vector-valued function. Notice the similarity with the definition of the directional derivative. By giving a small nudge to \\(t\\) , we are moving the \\(\\vec{v}\\) a little bit, and as a result we have a small change in \\(f\\) . The change in \\(f\\) is given by the derivative of \\(\\vec{v}\\) . Or in other words, we are moving into the direction of \\(\\vec{v}'(t)\\) . This beautiful results tells us that the multivariable chain rule is essentially a directional derivative in the direction of \\(\\vec v'(t)\\) : \\[ \\nabla f(\\vec{v}(t)) \\cdot \\vec{v}'(t) = \\nabla_{\\vec{v}'(t)} f(\\vec v(t)). \\]","title":"Multivariable chain rule"},{"location":"calculus/single-variable/derivatives/","text":"Single variable derivatives Formal definition Let \\(f(x)\\) be a function with a single variable \\(x\\) , then the formal definition of the derivative is: \\[ \\dfrac{\\mathrm{d}f}{\\mathrm{d}x} = \\lim_{h \\rightarrow 0} \\dfrac{f(x+h) - f(x)}{h}. \\] Standard derivative table This table contains the derivatives of the most common functions: \\(f(x)\\) \\(f'(x)\\) \\(k\\) \\(0\\) \\(x\\) \\(1\\) \\(x^k\\) \\(kx^{k-1}\\) \\(\\cos x\\) \\(-\\sin x\\) \\(\\sin x\\) \\(\\cos x\\) \\(\\tan x\\) \\(\\sec^2 x\\) \\(\\cot x\\) \\(-\\csc^2 x\\) \\(\\sec x\\) \\(\\sec x \\tan x\\) \\(\\csc x\\) \\(-\\csc x \\cot x\\) \\(\\ln x\\) \\(\\frac{1}{x}\\) \\(e^x\\) \\(e^x\\) \\(k^x\\) \\((\\ln k)k^x\\)","title":"Single variable derivatives"},{"location":"calculus/single-variable/derivatives/#single-variable-derivatives","text":"","title":"Single variable derivatives"},{"location":"calculus/single-variable/derivatives/#formal-definition","text":"Let \\(f(x)\\) be a function with a single variable \\(x\\) , then the formal definition of the derivative is: \\[ \\dfrac{\\mathrm{d}f}{\\mathrm{d}x} = \\lim_{h \\rightarrow 0} \\dfrac{f(x+h) - f(x)}{h}. \\]","title":"Formal definition"},{"location":"calculus/single-variable/derivatives/#standard-derivative-table","text":"This table contains the derivatives of the most common functions: \\(f(x)\\) \\(f'(x)\\) \\(k\\) \\(0\\) \\(x\\) \\(1\\) \\(x^k\\) \\(kx^{k-1}\\) \\(\\cos x\\) \\(-\\sin x\\) \\(\\sin x\\) \\(\\cos x\\) \\(\\tan x\\) \\(\\sec^2 x\\) \\(\\cot x\\) \\(-\\csc^2 x\\) \\(\\sec x\\) \\(\\sec x \\tan x\\) \\(\\csc x\\) \\(-\\csc x \\cot x\\) \\(\\ln x\\) \\(\\frac{1}{x}\\) \\(e^x\\) \\(e^x\\) \\(k^x\\) \\((\\ln k)k^x\\)","title":"Standard derivative table"},{"location":"color/HSV/","text":"Color functions HSV2RGB Image by https://doc.qt.io 1 2 3 4 5 vec3 hsv2rgb ( vec3 c ) { vec4 K = vec4 ( 1.0 , 2.0 / 3.0 , 1.0 / 3.0 , 3.0 ); vec3 p = abs ( fract ( c . xxx + K . xyz ) * 6.0 - K . www ); return c . z * mix ( K . xxx , clamp ( p - K . xxx , 0.0 , 1.0 ), c . y ); }","title":"Color functions"},{"location":"color/HSV/#color-functions","text":"","title":"Color functions"},{"location":"color/HSV/#hsv2rgb","text":"Image by https://doc.qt.io 1 2 3 4 5 vec3 hsv2rgb ( vec3 c ) { vec4 K = vec4 ( 1.0 , 2.0 / 3.0 , 1.0 / 3.0 , 3.0 ); vec3 p = abs ( fract ( c . xxx + K . xyz ) * 6.0 - K . www ); return c . z * mix ( K . xxx , clamp ( p - K . xxx , 0.0 , 1.0 ), c . y ); }","title":"HSV2RGB"},{"location":"computer-graphics/3d-sdf-shapes/","text":"3D SDF Shapes Sphere A sphere has a single parameter r , which is the radius of the sphere. 1 2 3 float sdSphere ( in vec3 p , float r ) { return length ( p ) - r ; } Box A box has three parameters, which are stored in a vec3 . These are used to define the width, length, and height of the box. 1 2 3 4 5 float sdBox ( vec3 p , vec3 b ) { vec3 q = abs ( p ) - b ; return length ( max ( q , 0.0 )) + min ( max ( q . x , max ( q . y , q . z )), 0.0 ); } Credits https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm","title":"3D SDF Shapes"},{"location":"computer-graphics/3d-sdf-shapes/#3d-sdf-shapes","text":"","title":"3D SDF Shapes"},{"location":"computer-graphics/3d-sdf-shapes/#sphere","text":"A sphere has a single parameter r , which is the radius of the sphere. 1 2 3 float sdSphere ( in vec3 p , float r ) { return length ( p ) - r ; }","title":"Sphere"},{"location":"computer-graphics/3d-sdf-shapes/#box","text":"A box has three parameters, which are stored in a vec3 . These are used to define the width, length, and height of the box. 1 2 3 4 5 float sdBox ( vec3 p , vec3 b ) { vec3 q = abs ( p ) - b ; return length ( max ( q , 0.0 )) + min ( max ( q . x , max ( q . y , q . z )), 0.0 ); }","title":"Box"},{"location":"computer-graphics/3d-sdf-shapes/#credits","text":"https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm","title":"Credits"},{"location":"computer-graphics/lighting/","text":"Lighting models All the lighting models described on this page use the following notation, as illustrated in the image below. Source \u2014 Wikipedia Let \\(\\mathbf{P}\\) be the point on the surface, then: \\(\\mathbf{N}\\) is the normal vector of the surface at \\(\\mathbf{P}\\) . \\(\\mathbf{L}\\) is the vector from \\(\\mathbf{P}\\) to the light source. \\(\\mathbf{V}\\) is the vector from \\(\\mathbf{P}\\) to the camera (eye). \\(\\mathbf{H}\\) is the halfway vector between \\(\\mathbf{L}\\) and \\(\\mathbf{V}\\) . \\(\\mathbf{R}\\) is the reflected vector \\(\\mathbf{V}\\) around \\(\\mathbf{N}\\) . To find the reflection vector, we can use \\(\\mathbf{R} = \\mathbf{V} - 2(\\mathbf{V}\\cdot\\mathbf{N})\\mathbf{N}\\) , where \\(\\mathbf{V}\\cdot\\mathbf{N}\\) is a dot-product. To find the halfway vector, we can use \\(\\mathbf{H} = \\dfrac{\\mathbf{L}+\\mathbf{V}}{||\\ \\mathbf{L}+\\mathbf{V}\\ ||}\\) . Attention Note that all of these vectors must be normalized, which is often denoted with a hat, like \\(\\mathbf{\\hat{N}}\\) . Lambertian Lambertian reflectance looks like an ideal \"matte\" or diffuse reflecting material. It is based on the angle between the light \\(\\mathbf{L}\\) and the surface normal \\(\\mathbf{N}\\) : \\[ I_D = \\mathbf{L}\\cdot\\mathbf{N}CI_L \\] where 1 2 3 4 float brdf_lambertian ( vec3 N , vec3 L ) { float k = clamp ( dot ( N , L ), 0. , 1. ); return k ; } Lambertian (wrapped) Wrapping the light can be used to fake subsurface scattering or area light. A parameter wrap is used which is a value between \\([0, 1]\\) . 1 2 3 4 5 float brdf_lambertian_wrapped ( vec3 N , vec3 L ) { float wrap = 0.5 ; float k = max ( 0. , ( dot ( L , N ) + wrap ) / ( 1. + wrap )); return k ; } Phong 1 2 3 4 float brdf_phong ( vec3 R , vec3 V , float exponent ) { float k = pow ( max ( 0. , dot ( R , V )), exponent ); return k ; } Blinn-Phong TBA Gaussian 1 2 3 4 5 6 float brdf_gaussian ( vec3 N , vec3 H , float m ) { float NHm = angle ( N , H ) / m ; float NHm2 = NHm * NHm ; float k = exp ( - NHm2 ); return k ; } Beckmann 1 2 3 4 5 6 7 8 9 10 float brdf_beckmann ( vec3 N , vec3 H , float m ) { float NdotH = dot ( N , H ); float tana = length ( cross ( N , H )) / NdotH ; float cosa = NdotH ; float m2 = m * m ; float tana2 = tana * tana ; float cosa4 = pow ( abs ( cosa ), 4. ); float k = exp ( - tana2 / m2 ) / ( 3.14159 * m2 * cosa4 ); return k ; } GGX The GGX lighting model is a microfacet model for refracting through rough surfaces. It is also a model that is becoming popular for lighting in video games. [1] The GGX lighting model is derived in this paper . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 float G1V ( float dotNV , float k ) { return 1.0 / ( dotNV * ( 1.0 - k ) + k ); } float brdf_ggx ( vec3 N , vec3 V , vec3 L , float roughness , float F0 ) { float alpha = roughness * roughness ; vec3 H = normalize ( V + L ); float dotNL = clamp ( dot ( N , L ), 0. , 1. ); float dotNV = clamp ( dot ( N , V ), 0. , 1. ); float dotNH = clamp ( dot ( N , H ), 0. , 1. ); float dotLH = clamp ( dot ( L , H ), 0. , 1. ); float alphaSqr = alpha * alpha ; float pi = 3.14159 ; float denom = dotNH * dotNH * ( alphaSqr - 1.0 ) + 1.0 ; float D = alphaSqr / ( pi * denom * denom ); float dotLH5 = pow ( 1.0 - dotLH , 5.0 ); float F = F0 + ( 1.0 - F0 ) * dotLH5 ; float k = alpha / 2.0 ; float vis = G1V ( dotNL , k ) * G1V ( dotNV , k ); return dotNL * D * F * vis ; } Author: John Hable Further Reading Physically Based Lighting at Pixar Physically Based Shading at Disney Real Shading in Unreal Engine 4 References [1] Optimizing GGX Shaders with dot(L,H)","title":"Lighting models"},{"location":"computer-graphics/lighting/#lighting-models","text":"All the lighting models described on this page use the following notation, as illustrated in the image below. Source \u2014 Wikipedia Let \\(\\mathbf{P}\\) be the point on the surface, then: \\(\\mathbf{N}\\) is the normal vector of the surface at \\(\\mathbf{P}\\) . \\(\\mathbf{L}\\) is the vector from \\(\\mathbf{P}\\) to the light source. \\(\\mathbf{V}\\) is the vector from \\(\\mathbf{P}\\) to the camera (eye). \\(\\mathbf{H}\\) is the halfway vector between \\(\\mathbf{L}\\) and \\(\\mathbf{V}\\) . \\(\\mathbf{R}\\) is the reflected vector \\(\\mathbf{V}\\) around \\(\\mathbf{N}\\) . To find the reflection vector, we can use \\(\\mathbf{R} = \\mathbf{V} - 2(\\mathbf{V}\\cdot\\mathbf{N})\\mathbf{N}\\) , where \\(\\mathbf{V}\\cdot\\mathbf{N}\\) is a dot-product. To find the halfway vector, we can use \\(\\mathbf{H} = \\dfrac{\\mathbf{L}+\\mathbf{V}}{||\\ \\mathbf{L}+\\mathbf{V}\\ ||}\\) . Attention Note that all of these vectors must be normalized, which is often denoted with a hat, like \\(\\mathbf{\\hat{N}}\\) .","title":"Lighting models"},{"location":"computer-graphics/lighting/#lambertian","text":"Lambertian reflectance looks like an ideal \"matte\" or diffuse reflecting material. It is based on the angle between the light \\(\\mathbf{L}\\) and the surface normal \\(\\mathbf{N}\\) : \\[ I_D = \\mathbf{L}\\cdot\\mathbf{N}CI_L \\] where 1 2 3 4 float brdf_lambertian ( vec3 N , vec3 L ) { float k = clamp ( dot ( N , L ), 0. , 1. ); return k ; }","title":"Lambertian"},{"location":"computer-graphics/lighting/#lambertian-wrapped","text":"Wrapping the light can be used to fake subsurface scattering or area light. A parameter wrap is used which is a value between \\([0, 1]\\) . 1 2 3 4 5 float brdf_lambertian_wrapped ( vec3 N , vec3 L ) { float wrap = 0.5 ; float k = max ( 0. , ( dot ( L , N ) + wrap ) / ( 1. + wrap )); return k ; }","title":"Lambertian (wrapped)"},{"location":"computer-graphics/lighting/#phong","text":"1 2 3 4 float brdf_phong ( vec3 R , vec3 V , float exponent ) { float k = pow ( max ( 0. , dot ( R , V )), exponent ); return k ; }","title":"Phong"},{"location":"computer-graphics/lighting/#blinn-phong","text":"TBA","title":"Blinn-Phong"},{"location":"computer-graphics/lighting/#gaussian","text":"1 2 3 4 5 6 float brdf_gaussian ( vec3 N , vec3 H , float m ) { float NHm = angle ( N , H ) / m ; float NHm2 = NHm * NHm ; float k = exp ( - NHm2 ); return k ; }","title":"Gaussian"},{"location":"computer-graphics/lighting/#beckmann","text":"1 2 3 4 5 6 7 8 9 10 float brdf_beckmann ( vec3 N , vec3 H , float m ) { float NdotH = dot ( N , H ); float tana = length ( cross ( N , H )) / NdotH ; float cosa = NdotH ; float m2 = m * m ; float tana2 = tana * tana ; float cosa4 = pow ( abs ( cosa ), 4. ); float k = exp ( - tana2 / m2 ) / ( 3.14159 * m2 * cosa4 ); return k ; }","title":"Beckmann"},{"location":"computer-graphics/lighting/#ggx","text":"The GGX lighting model is a microfacet model for refracting through rough surfaces. It is also a model that is becoming popular for lighting in video games. [1] The GGX lighting model is derived in this paper . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 float G1V ( float dotNV , float k ) { return 1.0 / ( dotNV * ( 1.0 - k ) + k ); } float brdf_ggx ( vec3 N , vec3 V , vec3 L , float roughness , float F0 ) { float alpha = roughness * roughness ; vec3 H = normalize ( V + L ); float dotNL = clamp ( dot ( N , L ), 0. , 1. ); float dotNV = clamp ( dot ( N , V ), 0. , 1. ); float dotNH = clamp ( dot ( N , H ), 0. , 1. ); float dotLH = clamp ( dot ( L , H ), 0. , 1. ); float alphaSqr = alpha * alpha ; float pi = 3.14159 ; float denom = dotNH * dotNH * ( alphaSqr - 1.0 ) + 1.0 ; float D = alphaSqr / ( pi * denom * denom ); float dotLH5 = pow ( 1.0 - dotLH , 5.0 ); float F = F0 + ( 1.0 - F0 ) * dotLH5 ; float k = alpha / 2.0 ; float vis = G1V ( dotNL , k ) * G1V ( dotNV , k ); return dotNL * D * F * vis ; } Author: John Hable","title":"GGX"},{"location":"computer-graphics/lighting/#further-reading","text":"Physically Based Lighting at Pixar Physically Based Shading at Disney Real Shading in Unreal Engine 4","title":"Further Reading"},{"location":"computer-graphics/lighting/#references","text":"[1] Optimizing GGX Shaders with dot(L,H)","title":"References"},{"location":"computer-graphics/math/","text":"Math functions Rotation matrix This will set up a 2D rotation matrix. It requires an angle a , and returns a mat2 . Multiply the vector with the matrix to rotate it. 1 2 3 4 mat2 rotate ( float a ) { float si = sin ( a ), co = cos ( a ); return mat2 ( co , si , - si , co ); } Info This 2D rotation matrix can also be used for 3D rotations. For example, to rotate on the Y-axis: 1 p . xz *= rotate ( angle ); Smoothstep The smoothstep is, in basis, a linear interpolation of the following two functions: \\(f(x) = x^2\\) . \\(g(x) = 1 - (x - 1)^2\\) . Which we then interpolate: \\[ h(x) = f(x)(1 -x) + g(x)x. \\] With some algebra, clamping, and parametrizing the slope, we get the complete definition of the smoothstep function: \\[ \\textrm{smoothstep}(x, t_1, t_2) := k^2(3-2k) \\] where \\(k\\) is \\[ \\max\\left\\{0, \\min\\left\\{1, \\dfrac{x - t_1}{t_2 - t_1} \\right\\} \\right\\}. \\] Implementing this in GLSL gives: 1 2 3 4 float smoothstep ( float x , float t1 , float t2 ) { float k = max ( 0. , min ( 1. , ( x - t1 ) / ( t2 - t1 ))); return k * k * ( 3 - 2 * k ); } Map This function will map \\(x\\) , with a range of \\([a, b]\\) , to the range \\([c, d]\\) . 1 2 3 float map ( float x , float start1 , float stop1 , float start2 , float stop2 ) { return start2 + ( stop2 - start2 ) * (( value - start1 ) / ( stop1 - start1 )); }","title":"Math functions"},{"location":"computer-graphics/math/#math-functions","text":"","title":"Math functions"},{"location":"computer-graphics/math/#rotation-matrix","text":"This will set up a 2D rotation matrix. It requires an angle a , and returns a mat2 . Multiply the vector with the matrix to rotate it. 1 2 3 4 mat2 rotate ( float a ) { float si = sin ( a ), co = cos ( a ); return mat2 ( co , si , - si , co ); } Info This 2D rotation matrix can also be used for 3D rotations. For example, to rotate on the Y-axis: 1 p . xz *= rotate ( angle );","title":"Rotation matrix"},{"location":"computer-graphics/math/#smoothstep","text":"The smoothstep is, in basis, a linear interpolation of the following two functions: \\(f(x) = x^2\\) . \\(g(x) = 1 - (x - 1)^2\\) . Which we then interpolate: \\[ h(x) = f(x)(1 -x) + g(x)x. \\] With some algebra, clamping, and parametrizing the slope, we get the complete definition of the smoothstep function: \\[ \\textrm{smoothstep}(x, t_1, t_2) := k^2(3-2k) \\] where \\(k\\) is \\[ \\max\\left\\{0, \\min\\left\\{1, \\dfrac{x - t_1}{t_2 - t_1} \\right\\} \\right\\}. \\] Implementing this in GLSL gives: 1 2 3 4 float smoothstep ( float x , float t1 , float t2 ) { float k = max ( 0. , min ( 1. , ( x - t1 ) / ( t2 - t1 ))); return k * k * ( 3 - 2 * k ); }","title":"Smoothstep"},{"location":"computer-graphics/math/#map","text":"This function will map \\(x\\) , with a range of \\([a, b]\\) , to the range \\([c, d]\\) . 1 2 3 float map ( float x , float start1 , float stop1 , float start2 , float stop2 ) { return start2 + ( stop2 - start2 ) * (( value - start1 ) / ( stop1 - start1 )); }","title":"Map"},{"location":"computer-graphics/rendering/","text":"Rendering Camera This is used to create an orthonormal basis for the camera. This can then be used to easily navigate the camera, because we have vectors to go forward, left, or up (and the inverse of those). 1 2 3 4 5 6 vec3 ro = vec3 ( 0 , 0 , - 1. ); vec3 ta = vec3 ( 0 , 0 , 0 ); vec3 ww = normalize ( ta - ro ); vec3 uu = normalize ( cross ( ww , vec3 ( 0 , 1 , 0 ))); vec3 vv = normalize ( cross ( uu , ww )); vec3 rd = normalize ( uv . x * uu + uv . y * vv + 1.0 * ww ); \\(\\textrm{ro}\\) is the ray origin. \\(\\textrm{ta}\\) is the target (where we are looking at). \\(\\textrm{ww}\\) , \\(\\textrm{uu}\\) , \\(\\textrm{vv}\\) is the orthonormal basis. \\(\\textrm{rd}\\) is the ray direction. Raymarcher Description A raymarching algorithm will intersect the scene by stepping a ray into the scene. At each step the distance, \\(d\\) , to the nearest object is calculated with a signed distance function, which is then used as the distance to safely step forward. An object is hit when the distance is smaller than some \\(\\epsilon\\) , for example: \\(d < 0.001\\) . This illustration visualizes this process. Image by https://adrianb.io The algorithm requires a ray origin ro , and a ray direction rd as input. The output of the algorithm is a value t , which is the distance from the origin to the intersection point. This intersection point \\(P\\) is then calculated with \\(P = \\textrm{ro} + t\\cdot \\textrm{rd}.\\) The algorithm has the following global parameters: Variable Description MIN_MARCH_DISTANCE The minimum distance to the object to qualify as a hit. Lower values will increase the detail, but slow down the algorithm. MAX_MARCH_DISTANCE The maximum distance that a ray is allowed to travel. Larger values will render the scene further, but slow down the algorithm. MAX_MARCH_STEP The maximum amount of steps the algorithm is allowed to take. Increase this if the detail between complex objects is poor. Higher values will slow down the algorithm. Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #define MIN_MARCH_DIST 0.001 #define MAX_MARCH_DIST 20. #define MAX_MARCH_STEPS 60. float march ( in vec3 ro , in vec3 rd ) { float t = 0. ; float i = 0. ; for ( i = 0. ; i < MAX_MARCH_STEPS ; i ++ ) { vec3 p = ro + t * rd ; float d = map ( p ); if ( d < MIN_MARCH_DIST ) break ; t += d ; if ( t > MAX_MARCH_DIST ) break ; } if ( i >= MAX_MARCH_STEPS ) { t = MAX_MARCH_DIST ; } return t ; } See demo Info The algorithm requires a map(vec3 point) function (line 9), which is the output of a 3D SDF , for example: 1 2 3 float map ( vec3 p ) { return length ( p ) - 0.5 ; // Circle SDF } Normals A normal vector is the vector \\(\\nabla f(\\mathbf{X})\\) . This can be calculated numerically with the central differences method. 1 2 3 4 5 6 7 vec3 normal ( in vec3 p ) { float eps = MIN_MARCH_DIST ; vec2 h = vec2 ( eps , 0 ); return normalize ( vec3 ( map ( p + h . xyy ) - map ( p - h . xyy ), map ( p + h . yxy ) - map ( p - h . yxy ), map ( p + h . yyx ) - map ( p - h . yyx ))); }","title":"Rendering"},{"location":"computer-graphics/rendering/#rendering","text":"","title":"Rendering"},{"location":"computer-graphics/rendering/#camera","text":"This is used to create an orthonormal basis for the camera. This can then be used to easily navigate the camera, because we have vectors to go forward, left, or up (and the inverse of those). 1 2 3 4 5 6 vec3 ro = vec3 ( 0 , 0 , - 1. ); vec3 ta = vec3 ( 0 , 0 , 0 ); vec3 ww = normalize ( ta - ro ); vec3 uu = normalize ( cross ( ww , vec3 ( 0 , 1 , 0 ))); vec3 vv = normalize ( cross ( uu , ww )); vec3 rd = normalize ( uv . x * uu + uv . y * vv + 1.0 * ww ); \\(\\textrm{ro}\\) is the ray origin. \\(\\textrm{ta}\\) is the target (where we are looking at). \\(\\textrm{ww}\\) , \\(\\textrm{uu}\\) , \\(\\textrm{vv}\\) is the orthonormal basis. \\(\\textrm{rd}\\) is the ray direction.","title":"Camera"},{"location":"computer-graphics/rendering/#raymarcher","text":"","title":"Raymarcher"},{"location":"computer-graphics/rendering/#description","text":"A raymarching algorithm will intersect the scene by stepping a ray into the scene. At each step the distance, \\(d\\) , to the nearest object is calculated with a signed distance function, which is then used as the distance to safely step forward. An object is hit when the distance is smaller than some \\(\\epsilon\\) , for example: \\(d < 0.001\\) . This illustration visualizes this process. Image by https://adrianb.io The algorithm requires a ray origin ro , and a ray direction rd as input. The output of the algorithm is a value t , which is the distance from the origin to the intersection point. This intersection point \\(P\\) is then calculated with \\(P = \\textrm{ro} + t\\cdot \\textrm{rd}.\\) The algorithm has the following global parameters: Variable Description MIN_MARCH_DISTANCE The minimum distance to the object to qualify as a hit. Lower values will increase the detail, but slow down the algorithm. MAX_MARCH_DISTANCE The maximum distance that a ray is allowed to travel. Larger values will render the scene further, but slow down the algorithm. MAX_MARCH_STEP The maximum amount of steps the algorithm is allowed to take. Increase this if the detail between complex objects is poor. Higher values will slow down the algorithm.","title":"Description"},{"location":"computer-graphics/rendering/#code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #define MIN_MARCH_DIST 0.001 #define MAX_MARCH_DIST 20. #define MAX_MARCH_STEPS 60. float march ( in vec3 ro , in vec3 rd ) { float t = 0. ; float i = 0. ; for ( i = 0. ; i < MAX_MARCH_STEPS ; i ++ ) { vec3 p = ro + t * rd ; float d = map ( p ); if ( d < MIN_MARCH_DIST ) break ; t += d ; if ( t > MAX_MARCH_DIST ) break ; } if ( i >= MAX_MARCH_STEPS ) { t = MAX_MARCH_DIST ; } return t ; } See demo Info The algorithm requires a map(vec3 point) function (line 9), which is the output of a 3D SDF , for example: 1 2 3 float map ( vec3 p ) { return length ( p ) - 0.5 ; // Circle SDF }","title":"Code"},{"location":"computer-graphics/rendering/#normals","text":"A normal vector is the vector \\(\\nabla f(\\mathbf{X})\\) . This can be calculated numerically with the central differences method. 1 2 3 4 5 6 7 vec3 normal ( in vec3 p ) { float eps = MIN_MARCH_DIST ; vec2 h = vec2 ( eps , 0 ); return normalize ( vec3 ( map ( p + h . xyy ) - map ( p - h . xyy ), map ( p + h . yxy ) - map ( p - h . yxy ), map ( p + h . yyx ) - map ( p - h . yyx ))); }","title":"Normals"},{"location":"geometry/geometry/","text":"Geometry Discrete Differential Geometry - Youtube series from CMU Discrete Differential Geometry - An Applied Introduction","title":"Geometry"},{"location":"geometry/geometry/#geometry","text":"Discrete Differential Geometry - Youtube series from CMU Discrete Differential Geometry - An Applied Introduction","title":"Geometry"}]}